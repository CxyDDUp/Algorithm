# 数组

## 704.二分查找

<font color=red>Tips:</font>

+ 有序数组
+ 数组中**没有重复元素**

### 题目描述：

​	给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

### 解法：

```python
左闭右闭
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  

        while left <= right:
            middle =  (right + left) // 2
            
            if nums[middle] > target:
                right = middle - 1  
            elif nums[middle] < target:
                left = middle + 1 
            else:
                return middle 
        return -1  
    
左闭右开
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)  

        while left < right:
            middle =  (right + left) // 2
            
            if nums[middle] > target:
                right = middle   
            elif nums[middle] < target:
                left = middle  
            else:
                return middle 
        return -1  
```

### 总结：

1. 左闭右开与左闭右闭：关键在于区分该区间是否包含最右值，其对循环条件和middle取值有影响
2. 若右闭，则left==right也符合条件，也可进入循环；

​      若右开，当left==right时，由于最右值不可取，所以不可进入循环；

3. 若右闭，则最右值可取，由于middle处取值≠key，所以将left变为middle+1或者将right变为middle-1；

​      若右开，则最右值不可取，所以可直接将left和right变为middle。

4. 为啥不根据右闭右开去进行讨论呢？

> 我觉得是因为 middle的算式，由于都是向下进行取整的，所以在特殊情况时，若是只剩下俩元素去寻找target，那么此时middle等于左边元素的下标，因此left需要一直能够取到！！！

5. ==一定要注意！！！==：当默认左闭右开时，一开始的时候就要让right呆在len(nums)，因为假设target就是在下标最大处取得，那就得不到结果了，所以当采取“左闭右开”原则时，一定要让初始的right呆在最大下标+1

### 相关题目：

#### 35. 搜索插入位置

##### 题目描述：

​	给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

##### 解法：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1

        while(left <= right):
            mid = (left + right) // 2

            if(nums[mid] == target):
                return mid
            elif(nums[mid] < target):
                left = mid + 1
            else:
                right = mid - 1
        return left
        
```

##### 总结：

+ ⚠️这题题干：若目标值不存在于数组中，则返回它将会被按顺序插入的位置！！！

#### ⚠️34. 在排序数组中查找元素的第一个和第二个位置

##### 题目描述：

​	给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

​	如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

​	你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

##### 解法：

+ 解法一：分别找出左边界和右边界，

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def getRightBorder(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            rightBoder = -2 # 记录一下rightBorder没有被赋值的情况
            while left <= right:
                middle = left + (right-left) // 2
                if nums[middle] > target:
                    right = middle - 1
                elif(nums[middle] < target) : # 寻找右边界，nums[middle] == target的时候更新left						
                  	left = middle + 1
                else:
                    rightBoder = left #所找到的不一定是最右边的边界，所以还需要向右进行查找
                    left = middle + 1
    
            return rightBoder
        
        def getLeftBorder(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1 
            leftBoder = -2 # 记录一下leftBorder没有被赋值的情况
            while left <= right:
                middle = left + (right-left) // 2
                if nums[middle] > target: #  寻找左边界，nums[middle] == target的时候更新right
                    right = middle - 1
                elif(nums[middle] == target)  
                    leftBoder = right 
                  	right = middle - 1 #因为这时候不确定是否左边还有等于target的值，因此还需要向左进行寻找
                else:
                    left = middle + 1
            return leftBoder
        leftBoder = getLeftBorder(nums, target)
        rightBoder = getRightBorder(nums, target)
        # 情况一
        if leftBoder == -2 or rightBoder == -2: return [-1, -1]
        # 情况三
        if rightBoder -leftBoder >1: return [leftBoder + 1, rightBoder - 1]
        # 情况二
        return [-1, -1]
```

+ 解法二

```python
# 解法2
# 1、首先，在 nums 数组中二分查找 target；
# 2、如果二分查找失败，则 binarySearch 返回 -1，表明 nums 中没有 target。此时，searchRange 直接返回 {-1, -1}；
# 3、如果二分查找成功，则 binarySearch 返回 nums 中值为 target 的一个下标。然后，通过左右滑动指针，来找到符合题意的区间
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) // 2
                if nums[middle] > target:
                    right = middle - 1
                elif nums[middle] < target: 
                    left = middle + 1
                else:
                    return middle
            return -1
        index = binarySearch(nums, target)
        if index == -1:return [-1, -1] # nums 中不存在 target，直接返回 {-1, -1}
        # nums 中存在 target，则左右滑动指针，来找到符合题意的区间
        left, right = index, index
        # 向左滑动，找左边界
        while left -1 >=0 and nums[left - 1] == target: left -=1
        # 向右滑动，找右边界
        while right+1 < len(nums) and nums[right + 1] == target: right +=1
        return [left, right]
```

+ 解法三

```python
# 解法3
# 1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标（左边界）与第一个大于target的下标（右边界）；
# 2、如果左边界<= 右边界，则返回 [左边界, 右边界]。否则返回[-1, -1]
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int, lower:bool) -> int:
            left, right = 0, len(nums)-1
            ans = len(nums)
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) //2 
                # lower为True，执行前半部分，找到第一个大于等于 target的下标 ，否则找到第一个大于target的下标
                if nums[middle] > target or (lower and nums[middle] >= target): 
                    right = middle - 1
                    ans = middle
                else: 
                    left = middle + 1
            return ans

        leftBorder = binarySearch(nums, target, True) # 搜索左边界
        rightBorder = binarySearch(nums, target, False) -1  # 搜索右边界
        if leftBorder<= rightBorder and rightBorder< len(nums) and nums[leftBorder] == target and  nums[rightBorder] == target:
            return [leftBorder, rightBorder]
        return [-1, -1]
```

+ 解法四

```python
# 解法4
# 1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标leftBorder；
# 2、在 nums 数组中二分查找得到第一个大于等于 target+1的下标， 减1则得到rightBorder；
# 3、如果开始位置在数组的右边或者不存在target，则返回[-1, -1] 。否则返回[leftBorder, rightBorder]
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) //2 
                if nums[middle] >= target: 
                    right = middle - 1
                else: 
                    left = middle + 1
            return left  # 若存在target，则返回第一个等于target的值 

        leftBorder = binarySearch(nums, target) # 搜索左边界
        rightBorder = binarySearch(nums, target+1) -1  # 搜索右边界
        if leftBorder == len(nums) or nums[leftBorder]!= target: # 情况一和情况二
            return [-1, -1]
        return [leftBorder, rightBorder]
```

##### 总结：

+ 这边最好用左闭右闭，因为这边的输出是左闭右闭
+ 本题目关键在于找到左右边界===！！！==
+ <font color=red>Tips:</font>利用二分法只能查找到是否有该target，但是无法确立边界，因此还需要不断向左向右去探索 相同target值的边界

+ 寻找target在数组里的左右边界，有如下三种情况：
  + 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
  + 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
  + 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}
+ 解法总结：
  + 找到左右边界，再判断左右边界是否符合要求
  + 找到左右边界：
    + 直接法：直接找到target的左边界，直接找到target的右边接
    + 间接法：
      + 找到target的值的最左边界 + 找到（target+1）的值的最左边界再下标减1
      + 找到target就行，再左右滑动

#### 69. x的平方根

##### 题目描述：

​	给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

​	由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去**

##### 解法：

我的笨拙解法😁

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        temp = 0
        while(1):
            rec = temp + 1
            if((temp * temp) == x ):
                return temp
            elif((temp * temp) > x):
                return temp - 1
            temp += 1
```

官方题解：利用二分法进行求解

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

```

##### 总结：

1. 由于 x 平方根的整数部分 ans 是满足 k^2^≤x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

2. 二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。

#### 367. 

##### 题目描述：

​	给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

​	**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

​	不能使用任何内置的库函数，如 `sqrt` 。

##### 解法：

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num 
        while(left <= right):
            mid = (left + right) // 2
            if (mid * mid) == num:
                return True
            elif (mid * mid) < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

##### 总结：

1. 二分法yyds
2. 注意⚠️python中的True一定得是大写首字母，False也是如此
3. 💡编写二分法时，要注意是利用mid去变换left和right的值

## 27.移除元素

### 题目描述:

​	给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

### 解法：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0
        i=0
        for i in range(0, len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k=k+1
        return k
```

### 总结：

1. Python语法：

+ python中并不存在k++，k--之类用法
+ python中的循环语句，条件语句要加冒号（:）
+ 求列表长度是len()函数，而不是lens()
+ 定义空列表可以用list()赋值，也可以直接令一个变量=[]

2. 快慢指针法

+ 快指针用来遍历原数组
+ 慢指针用来记录满足题设的有效数据

### 相关题目：

#### 	26. 删除有序数组中的重复项

##### 		题目描述：

​	给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

##### 		题解：

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 1
        while(fast < len(nums)):
            if(nums[slow] != nums[fast]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
```



##### 		总结：

		1. 很典型的快慢指针方法，快指针进行遍历，慢指针则负责用来记录有效的数值

#### 283. 移动零

##### 题目描述:

​	给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

##### 题解：

我的解答：二次遍历

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while(fast < len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while(slow < len(nums)):
            nums[slow] = 0
            slow += 1
```

官方解答：一次遍历

+ 基于交换+快速排序的原则

我的蹩脚算法

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i, j = 0, 1 #i找等于0的数，j找不等于0的数
        while(j < len(nums) and i < len(nums)):
            if(nums[i] == 0 and nums[j] != 0 and i < j):
                nums[i] = nums[j]
                nums[j] = 0
                i += 1
                j += 1
            elif(nums[i] != 0):
                i += 1
            elif(nums[j] == 0):
                j += 1
                
            if(i >= j):
                j += 1
```

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
		# 两个指针i和j
	    j = 0
	    for i in range(len(nums)):
	        # 当前元素!=0，就把其交换到左边，等于0的交换到右边
		    if nums[i]:
			    nums[j],nums[i] = nums[i],nums[j]
			    j += 1 #把j留在了等于0的位置
```



##### 总结：

1. 两次遍历的话，就是典型的快慢指针方法，慢指针记录非0元素，快指针遍历数组，但是由于还需要将0置于最后，所以还需要一次遍历
2. 一次遍历的话，主要是遍历数组中的每个元素，如果其非0则将其置换到左边，等于0的置换到右边

#### 844. 比较含退格的字符串

##### 题目描述：

​	给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

​	**注意：**如果对空文本输入退格字符，文本继续为空。

##### 题解：

+ 重构字符串
  + 最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。
  + 具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：
    + 如果它是退格符，那么我们将栈顶弹出；
    + 如果它是普通字符，那么我们将其压入栈中


```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        def build(s: str) -> str:
            ret = list()
            for ch in s:
                if ch != "#":
                    ret.append(ch)
                elif ret:
                    ret.pop()
            return "".join(ret)
        
        return build(S) == build(T)
```

+ 双指针法
  + 一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉
  + 具体地，我们定义 *skip* 表示当前待删除的字符的数量。每次我们遍历到一个字符：
    + 若该字符为退格符，则我们需要多删除一个普通字符，我们让 *skip* 加 1；
    + 若该字符为普通字符：
      + 若 *skip* 为 0，则说明当前字符不需要删去；
      + 若 *skip* 不为 0，则说明当前字符需要删去，我们让 *skip* 减 1

```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        i, j = len(S) - 1, len(T) - 1
        skipS = skipT = 0

        while i >= 0 or j >= 0:
            while i >= 0:
                if S[i] == "#":
                    skipS += 1
                    i -= 1
                elif skipS > 0:
                    skipS -= 1
                    i -= 1
                else:
                    break
            while j >= 0:
                if T[j] == "#":
                    skipT += 1
                    j -= 1
                elif skipT > 0:
                    skipT -= 1
                    j -= 1
                else:
                    break
            if i >= 0 and j >= 0:
                if S[i] != T[j]:
                    return False
            elif i >= 0 or j >= 0:
                return False
            i -= 1
            j -= 1
        
        return True

```

##### 总结：

1. 第一种可能更加贴近平时的积累，但是由于堆栈不经常使用了，还是需要强化记忆这部分
2. 第二种的话，我觉得主要是关于逆序遍历这种想法的没有意识，并且想到用skip去保存还需要退的元素个数，但其实本质上还是堆栈的问题没有解决！！！！因为后面的字母一定是保留在栈的最顶部的，所以保留！！！
3. 所以，需要培养堆栈的代码和思维意识！

### 977. 有序数组的平方

#### 题目描述：

​	给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

#### 题解：

+ 我的答案（好菜哦）==其实就是归并排序的思想👏==

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [] #保留最终结果的列表
        pivot = 0 #记录第一个大于等于0的数，中枢
        min_squre = nums[0] * nums[0]
        for i in range(len(nums)):
            if((nums[i] * nums[i]) <= min_squre):
                pivot = i
                min_squre = nums[i] * nums[i]
        i, j = pivot - 1, pivot #i向x轴负半轴遍历，j向x轴正半轴遍历
        while((i >= 0) and (j < len(nums))):
            if((nums[i] * nums[i]) <= (nums[j] * nums[j])):
                res.append(nums[i] * nums[i])
                i -= 1
            else:
                res.append(nums[j] * nums[j])
                j += 1
        while(j < len(nums)):
            res.append(nums[j] * nums[j])
            j += 1
        while(i >= 0):
            res.append(nums[i] * nums[i])
            i -= 1
        return res

```

+ 最优解(还是从逆序，反向思维去考虑)

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        i, j, pos = 0, n - 1, n - 1
        while i <= j:
            if nums[i] * nums[i] > nums[j] * nums[j]:
                ans[pos] = nums[i] * nums[i]
                i += 1
            else:
                ans[pos] = nums[j] * nums[j]
                j -= 1
            pos -= 1
        
        return ans

```

#### 总结：

1. 我的双指针解法，需要找到一个平方值最小的边界，然后往两侧去进行依次元素的平方比较。同时呢，又可以看成，左边是一个递减数列，右边是一个递增数列，然后对该两者进行一个递归排序
   1. ==这边容易错误的点==在于，一边达到边界之后，另一侧还需要继续访问！！！
   2. <font color = red>低级错误！！！</font> 一定要记得去更新！！！比如说这题的最小值，千万不能忘记了更新！！！
2. 官方最优双指针解法，不需要确认中间边界，直接从两端开始，利用双指针进行遍历！！！！

### 209. 长度最小的子数组

#### 题目描述：

​	给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

#### 题解：

+ 我的题解：暴力法，但是会导致最终的`target`很大时，超出时间限制

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        s_min = len(nums) #用来记录最小子数组的长度
        final_num = 0 #用来记录长度最小的子数组的和
        for i in range(len(nums)):
            total = nums[i] #用来记录子数组和
            s_real = 1 #用来记录实时滑动窗口大小
            j = i + 1
            while(j < len(nums) and total < target):
                total += nums[j]
                j += 1
                s_real += 1
            if(total >= target and s_real <= s_min):
                s_min = s_real
                final_num = target
        if(final_num >= target):
            return s_min
        else:
            return 0
```

+ 由于第一种暴力解法，需要两次遍历完整数组，也就是时间复杂度为$O(n^2)$，因此我们可以考虑在寻找最佳位置的时候使用二分法，来简化时间复杂度。==需要注意的是==二分法一定得是！！有序数组！！

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1
        sums = [0]
        for i in range(n):
            sums.append(sums[-1] + nums[i])
        
        for i in range(1, n + 1):
            target = s + sums[i - 1]
            bound = bisect.bisect_left(sums, target) #用于在 有序列表 中找到一个元素的插入位置，以保持列表的有序性。它返回的是第一个 大于等于目标值 的索引。
            if bound != len(sums):
                ans = min(ans, bound - (i - 1))
        
        return 0 if ans == n + 1 else ans
```

+ 滑动窗口法
  + 在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可以使用滑动窗口的方法。
  + 定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。
  + 初始状态下，*start* 和 *end* 都指向下标 0，*sum* 的值为 0。
  + 每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。


```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1
        start, end = 0, 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1
        
        return 0 if ans == n + 1 else ans

```

#### 总结：

1. 如下图所示出现的问题，由于前面的数据不满足题意，因此在出现有效子数组时，会导致``s_min`变量值变为1，以至于存储实际有效实时滑动窗口实效，导致最小窗口一直为1。

![image-20251008094059251](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251008094059251.png)

2. 二分法的使用还需加强，**`python`中的`bisect.bisect_left`的方法含义**
3. 滑动窗口法，主要是窗口可以自行根据与target值的大小关系进行放大和缩小

#### 相关题目：

####  904. 水果成蓝【中等】

##### 题目描述：

​	你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

​	你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

​	给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

##### 题解：

+ 我的解法：
  + 参考长度最小的子数组的解法，想到使用滑动窗口
  + 用`first` 、`second`来表示滑动窗口内的第一个、第二个出现的数字（==值得注意的是==第一个出现的字可能在滑动窗口的**最后**！！！）
  + `num_max`表示滑动窗口的最大值，更大值来不断更迭
  + `i`表示第一个数字出现的第一个位置，也就是滑动窗口的头部
  + `j`表示滑动窗口的尾部（<font color = red>注意：</font>尾部的数字可能是`first`也可能是`second`）
  + 算法逻辑：
    + 通过`j`逐步递增，不断遍历数组
    + 每次出现第三个数字时，记录为`loc`
    + 计算此时滑动数组的长度，如果大于`num_max`则替换其值
    + 同时记录滑动窗口最后出现的数为`first`并通过向前遍历，得到`first`第一次出现的地方记录为`i`
    + 再将`loc`赋值给`j`，回到第一步

```
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        if not fruits:
            return 0
        first, second = fruits[0], 0 #first记录滑动窗口中第一个篮子的水果，second记录第二个篮子的水果
        num_max = 0
        i, j =0, 1 #保存first出现的第一个位置, j保存second出现的最后一个位置
        loc = 0
        #找出第二个篮子装什么水果      
        while(j < len(fruits)):
            if (fruits[j] != first):
                second = fruits[j]
                j += 1 #保存第二个篮子数字第一次出现的位置
                break
            j += 1 #保存第二个篮子数字第一次出现的位置
        while(j < len(fruits)):
            if ((fruits[j] == first) or (fruits[j] == second)):
                j += 1
            else:
                if((j - i) > num_max):
                    num_max = j - i
                if fruits[j - 1] == first:
                    second = first
                loc = j
                j -= 1
                while(j >= 0):
                    if(fruits[j] == second):
                        j -= 1
                    else:
                        i = j + 1
                        first = second
                        second = fruits[loc]
                        j = loc
                        break
        if((j - i) > num_max):
            num_max = j - i
        return num_max



```

+ 官方解法
  + 我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。
  + 我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。
  + 需要注意的是，将 fruits[left] 从哈希表中移除后，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        cnt = Counter()

        left = ans = 0
        for right, x in enumerate(fruits):
            cnt[x] += 1
            while len(cnt) > 2:
                cnt[fruits[left]] -= 1
                if cnt[fruits[left]] == 0:
                    cnt.pop(fruits[left])
                left += 1
            ans = max(ans, right - left + 1)
        
        return ans

```

##### 总结：

+ 解题过程失误
  + 是保留最大or最小值，搞糊涂了，循环条件，`break`没有使用
  + 如果前一个滑动窗口的末尾数是first的时候，要记得灵活转换
+ 与哈希表的第一次代码邂逅

#### 76. 最小覆盖字串【困难】

##### 题目描述：

​	给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

##### 题解：

+ 我的解法

```python
解不出来啊啊啊啊，主要是哈希表并不是很精通🤔
```

+ 大佬解法

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need, missing = collections.Counter(t), len(t) #记录 t 中每个字符还“需要”的次数（例如 t="AAB" 则 need={'A':2,'B':1}）
        i = start = end = 0
        for j, c in enumerate(s, 1):
            missing -= need[c] > 0
            need[c] -= 1
            if not missing:
                while need[s[i]] < 0:
                    need[s[i]] += 1
                    i += 1
                if not end or j - i < end - start:
                    start, end = i, j
        return s[start:end]
```

![image-20251010090545849](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090545849.png)

![image-20251010090610781](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090610781.png)

##### 总结：

+ `enumerate(sequence, [start=0])`
  + sequence -- 一个序列、迭代器或其他支持迭代对象。
  + start -- 下标起始位置的值。

![image-20251010090216855](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090216855.png)

+ 涉及滑动窗口的问题，都会在一个遍历全局的大循环下进行，然后再依次滑动，寻找适合的最佳解！！
+ 可以用`baacbac`来举例子方便记忆，主要是`missing原来可以第一次为0之后一直为0`这一点，我第一次遇到有点难以理解，`missing`为0之后，就依靠哈希表`need`来调控收缩！！！

## 59. 螺旋矩阵II

### 题目描述：

​	给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

### 题解：

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        num_move = 2 * n - 1 #一共需要方向改变的移动次数 按照下、左、上、右的顺序执行
        k = 1 #记录第几次执行方向改变了
        count = 1 #记录下一个数应该被写做几
        flag = True #是否为第一次改变方向，因为只有第一次只有保持一次所需修改的数量
        i, j = 0, 0 #表示行和列，便于修改元素
        iftwo = 0 #只有当达到2的倍数时，n才会减1
        final = 0 #记录最后的行列，即需保存的变量
        while(k <= num_move):
            #处理第一次向右
            if(flag and k % 4 == 1):
                i = 0
                for m in range(n):
                    matrix[i][m] = count
                    count += 1
                flag = False
                j = n - 1 #保留下次处理的不变列标
                n -= 1 #总变化数➖1
                i += 1 #开始变化行标
                k += 1
            #处理非第一次向右
            elif(k % 4 == 1):
                for m in range(n):
                    matrix[i][j + m] = count
                    count += 1
                    final = j + m
                j = final
                i += 1
                iftwo += 1
                if(iftwo % 2 == 0):
                    n -= 1
                k += 1
            #处理向下
            elif(k % 4 == 2):
                for m in range(n):
                    matrix[i + m][j] = count
                    count += 1
                    final = i + m
                i = final
                j -= 1 
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
            #处理向左
            elif(k % 4 == 3):
                for m in range(n):
                    matrix[i][j - m] = count
                    count += 1
                    final = j - m
                j = final
                i -= 1
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
            #处理向上
            else:
                for m in range(n):
                    matrix[i - m][j] = count
                    count += 1
                    final = i - m
                i = final
                j += 1
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
        return matrix
 
```

![image-20251013093149397](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251013093149397.png)

<font color=red>官方的思路更加清晰，我的变量设置得很乱！</font>

### 总结：

1. 花了蛮长时间去做的，但是我很适合去暴力求解这些有规律的题目🤔哈哈哈，做出来还是很有成就感的
2. 注意的是：模拟过程！！
3. 值得注意⚠️的是，我自己设置的变量一定要记得变化呀==！！！！==

### 相关题目：

#### 54. 螺旋矩阵

##### 题目描述：

​	给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

##### 题解：

+ 模拟方法
  + 可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。
  + 判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
  + 如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 <= nextRow < rows and 0 <= nextColumn < columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order
```

+ 按层模拟
  + 可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。
  + 定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。
  + 对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于$(top,left)$，右下角位于 $(bottom,right)$，按照如下顺序遍历当前层的元素。

`````python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom:
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
`````

##### 总结：

1. 按层模拟，这个方法我觉得挺有效的！！！是一种化繁为简，逐层去考虑的思维方式！！！
2. 直接模拟的话，需要借助于辅助矩阵，判断是否被访问过，如果已经被访问过了，才会转向。同时，转向了，还需要记得修改移动路径和方式！！！