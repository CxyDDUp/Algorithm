# 数组

## 704.二分查找

<font color=red>Tips:</font>

+ 有序数组
+ 数组中**没有重复元素**

### 题目描述：

​	给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

### 解法：

```python
左闭右闭
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  

        while left <= right:
            middle =  (right + left) // 2
            
            if nums[middle] > target:
                right = middle - 1  
            elif nums[middle] < target:
                left = middle + 1 
            else:
                return middle 
        return -1  
    
左闭右开
class Solution:
    def search(self, nums: List[int], target: int) -> int:
      	# 易错点 len(nums)的取法
        left, right = 0, len(nums)  

        while left < right:
            middle =  (right + left) // 2
            
            if nums[middle] > target:
                right = middle   
            elif nums[middle] < target:
                left = middle + 1
            else:
                return middle 
        return -1  
```

### 总结：

1. 左闭右开与左闭右闭：关键在于区分该区间是否包含最右值，其对循环条件和middle取值有影响
2. 若右闭，则``left==right`也符合条件，也可进入循环；

​      若右开，当`left==right`时，由于最右值不可取，所以不可进入循环；

3. 若右闭，则最右值可取，由于``middle`处取值≠key，所以将`left`变为`middle+1`或者将`right`变为`middle-1`	；

​      若右开，则最右值不可取，所以可直接将``right`变为``middle`，左值依然为``middle+1`。

4. 为啥不根据右闭右开去进行讨论呢？

> 我觉得是因为 middle的算式，由于都是向下进行取整的，所以在特殊情况时，若是只剩下俩元素去寻找target，那么此时middle等于左边元素的下标，因此left需要一直能够取到！！！

5. ==一定要注意！！！==：当默认左闭右开时，一开始的时候就要让right呆在len(nums)，因为假设target就是在下标最大处取得，那就得不到结果了，所以当采取“左闭右开”原则时，一定要让初始的right呆在最大下标+1

### 相关题目：

#### 35. 搜索插入位置

##### 题目描述：

​	给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

##### 解法：

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1

        while(left <= right):
            mid = (left + right) // 2

            if(nums[mid] == target):
                return mid
            elif(nums[mid] < target):
                left = mid + 1
            else:
                right = mid - 1
        return left
        
```

##### 总结：

+ ⚠️这题题干：若目标值不存在于数组中，则返回它将会被按顺序插入的位置！！！

+ 若是左闭右闭的区间，当退出循环的时候`left = right + 1`【<font color =red>无论啥时候，都是这个关系！！！</font>】

+ 二分查找的循环不变量：

  + 左闭右闭：

    + 🧠关键洞察：==【不变量】==

    > - 所有 `< target` 的元素都在 `left` 左侧
    > - 所有 `> target` 的元素都在 `right` 右侧

    + 等价于

    > - `nums[0..left-1] < target`
    > - `nums[right+1..n-1] > target`

    + 当循环结束时，`left = right + 1`，所以：

    > - `nums[0..left-1] < target`
    > - `nums[left..n-1] > target`（因为 `right+1 = left`）

    + 因此，`left` 是第一个满足 `nums[i] >= target` 的位置。
    + 如果 `target` 不存在，`left` 就是**第一个大于 `target` 的位置**
    + 如果 `target` 存在，`left` 是**第一个等于 `target` 的位置**（如果你在 `==` 时没有提前返回，而是继续收缩）

    > ⚠️ 但在上面的代码中，`== target` 时我们直接返回了，所以最终 `left` 只会在“未找到”时被返回，此时它指向**第一个大于 `target` 的位置**

  + 左闭右开

    + 🧠关键洞察：==【不变量】==

    > - `nums[0..left-1] < target`
    > - `nums[right..n-1] >= target`

    + 当循环结束时，`left = right`，所以：

    > - `nums[0..left-1] < target`
    > - `nums[left..n-1] >= target`

    + 👉 因此，`left` 仍然是**第一个大于或等于 `target` 的位置**


#### ⚠️34. 在排序数组中查找元素的第一个和第二个位置

##### 题目描述：

​	给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

​	如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

​	你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

##### 解法：

+ ⚠️（有点☹️）解法一：分别找出左边界和右边界，

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def getRightBorder(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            rightBoder = -2 # 记录一下rightBorder没有被赋值的情况
            while left <= right:
                middle = left + (right-left) // 2
                if nums[middle] > target:
                    right = middle - 1
                elif(nums[middle] < target) : # 寻找右边界，nums[middle] == target的时候更新left						
                  	left = middle + 1
                else:
                    #rightBoder = left #所找到的不一定是最右边的边界，所以还需要向右进行查找
                    #left = middle + 1 #想错了啊！！！
                    #应该是先进行移动，再去赋值rightBoder，其记录的是target之后的第一个数
                    left = middle + 1
                    rightBoder = left
    
            return rightBoder
        
        def getLeftBorder(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1 
            leftBoder = -2 # 记录一下leftBorder没有被赋值的情况
            while left <= right:
                middle = left + (right-left) // 2
                if nums[middle] > target: #  寻找左边界，nums[middle] == target的时候更新right
                    right = middle - 1
                elif(nums[middle] == target)  
                		right = middle - 1
                    leftBoder = right #因为这时候不确定是否左边还有等于target的值，因此还需要向左进行寻找，而此时nums[left]不一定还等于target，而用leftBoder是用来找到target之前第一个数
                else:
                    left = middle + 1
            return leftBoder
        leftBoder = getLeftBorder(nums, target)
        rightBoder = getRightBorder(nums, target)
        # 情况一
        if leftBoder == -2 or rightBoder == -2: return [-1, -1]
        # 情况三
        if rightBoder -leftBoder >1: return [leftBoder + 1, rightBoder - 1]
        # 情况二
        return [-1, -1]
```

+ 解法二

```python
# 解法2
# 1、首先，在 nums 数组中二分查找 target；
# 2、如果二分查找失败，则 binarySearch 返回 -1，表明 nums 中没有 target。此时，searchRange 直接返回 {-1, -1}；
# 3、如果二分查找成功，则 binarySearch 返回 nums 中值为 target 的一个下标。然后，通过左右滑动指针，来找到符合题意的区间
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) // 2
                if nums[middle] > target:
                    right = middle - 1
                elif nums[middle] < target: 
                    left = middle + 1
                else:
                    return middle
            return -1
        index = binarySearch(nums, target)
        if index == -1:return [-1, -1] # nums 中不存在 target，直接返回 {-1, -1}
        # nums 中存在 target，则左右滑动指针，来找到符合题意的区间
        left, right = index, index
        # 向左滑动，找左边界
        while left -1 >=0 and nums[left - 1] == target: left -=1
        # 向右滑动，找右边界
        while right+1 < len(nums) and nums[right + 1] == target: right +=1
        return [left, right]
```

+ 解法三

```python
# 解法3
# 1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标（左边界）与第一个大于target的下标（右边界）；
# 2、如果左边界<= 右边界，则返回 [左边界, 右边界]。否则返回[-1, -1]
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int, lower:bool) -> int:
            left, right = 0, len(nums)-1
            ans = len(nums)
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) //2 
                # lower为True，执行前半部分，找到第一个大于等于 target的下标 ，否则找到第一个大于target的下标
                if nums[middle] > target or (lower and nums[middle] >= target): 
                    right = middle - 1
                    ans = middle
                else: 
                    left = middle + 1
            return ans

        leftBorder = binarySearch(nums, target, True) # 搜索左边界
        rightBorder = binarySearch(nums, target, False) -1  # 搜索右边界
        if leftBorder<= rightBorder and rightBorder< len(nums) and nums[leftBorder] == target and  nums[rightBorder] == target:
            return [leftBorder, rightBorder]
        return [-1, -1]
```

+ 解法四

```python
# 解法4
# 1、首先，在 nums 数组中二分查找得到第一个大于等于 target的下标leftBorder；
# 2、在 nums 数组中二分查找得到第一个大于等于 target+1的下标， 减1则得到rightBorder；
# 3、如果开始位置在数组的右边或者不存在target，则返回[-1, -1] 。否则返回[leftBorder, rightBorder]
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        def binarySearch(nums:List[int], target:int) -> int:
            left, right = 0, len(nums)-1
            while left<=right: # 不变量：左闭右闭区间
                middle = left + (right-left) //2 
                if nums[middle] >= target: 
                    right = middle - 1
                else: 
                    left = middle + 1
            return left  # 若存在target，则返回第一个等于target的值 

        leftBorder = binarySearch(nums, target) # 搜索左边界
        rightBorder = binarySearch(nums, target+1) -1  # 搜索右边界
        if leftBorder == len(nums) or nums[leftBorder]!= target: # 情况一和情况二
            return [-1, -1]
        return [leftBorder, rightBorder]
```

##### 总结：

+ 这边最好用左闭右闭，因为这边的输出是左闭右闭
+ 本题目关键在于找到左右边界===！！！==
+ <font color=red>Tips:</font>利用二分法只能查找到是否有该target，但是无法确立边界，因此还需要不断向左向右去探索 相同target值的边界

+ 寻找target在数组里的左右边界，有如下三种情况：
  + 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
  + 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
  + 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}
+ 解法总结：
  + 找到左右边界，再判断左右边界是否符合要求
  + 找到左右边界：
    + 直接法：直接找到target的左边界，直接找到target的右边界
    + 间接法：
      + 找到target的值的最左边界 + 找到（target+1）的值的最左边界再下标减1
      + 找到target就行，再左右滑动

#### 69. x的平方根

##### 题目描述：

​	给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

​	由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去**

##### 解法：

我的笨拙解法😁

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        temp = 0
        while(1):
            rec = temp + 1
            if((temp * temp) == x ):
                return temp
            elif((temp * temp) > x):
                return temp - 1
            temp += 1
```

官方题解：利用二分法进行求解

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r, ans = 0, x, -1
        while l <= r:
            mid = (l + r) // 2
            if mid * mid <= x:
                ans = mid
                l = mid + 1
            else:
                r = mid - 1
        return ans

```

##### 总结：

1. 由于 x 平方根的整数部分 ans 是满足 k^2^≤x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。

2. 二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。由于我们所有的运算都是整数运算，不会存在误差，因此在得到最终的答案 ans 后，也就不需要再去尝试 ans+1 了。

#### 367. 

##### 题目描述：

​	给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

​	**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

​	不能使用任何内置的库函数，如 `sqrt` 。

##### 解法：

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        left, right = 1, num 
        while(left <= right):
            mid = (left + right) // 2
            if (mid * mid) == num:
                return True
            elif (mid * mid) < num:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

##### 总结：

1. 二分法yyds
2. 注意⚠️python中的True一定得是大写首字母，False也是如此
3. 💡编写二分法时，要注意是利用mid去变换left和right的值

## 27.移除元素

### 题目描述:

​	给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

### 解法：

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        k=0
        i=0
        for i in range(0, len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k=k+1
        return k
```

### 总结：

1. Python语法：

+ python中并不存在k++，k--之类用法
+ python中的循环语句，条件语句要加冒号（:）
+ 求列表长度是len()函数，而不是lens()
+ 定义空列表可以用list()赋值，也可以直接令一个变量=[]

2. 快慢指针法

+ 快指针用来遍历原数组
+ 慢指针用来记录满足题设的有效数据

### 相关题目：

#### 	26. 删除有序数组中的重复项

##### 		题目描述：

​	给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

##### 		题解：

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 1
        while(fast < len(nums)):
            if(nums[slow] != nums[fast]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
```



##### 		总结：

		1. 很典型的快慢指针方法，快指针进行遍历，慢指针则负责用来记录有效的数值

#### 283. 移动零

##### 题目描述:

​	给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

##### 题解：

我的解答：二次遍历

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        slow, fast = 0, 0
        while(fast < len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        while(slow < len(nums)):
            nums[slow] = 0
            slow += 1
```

官方解答：一次遍历

+ 基于交换+快速排序的原则

我的蹩脚算法

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        i, j = 0, 1 #i找等于0的数，j找不等于0的数
        while(j < len(nums) and i < len(nums)):
            if(nums[i] == 0 and nums[j] != 0 and i < j):
                nums[i] = nums[j]
                nums[j] = 0
                i += 1
                j += 1
            elif(nums[i] != 0):
                i += 1
            elif(nums[j] == 0):
                j += 1
                
            if(i >= j):
                j += 1
```

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
		# 两个指针i和j
	    j = 0
	    for i in range(len(nums)):
	        # 当前元素!=0，就把其交换到左边，等于0的交换到右边
		    if nums[i]:
			    nums[j],nums[i] = nums[i],nums[j]
			    j += 1 #把j留在了等于0的位置
```

##### 总结：

1. 两次遍历的话，就是典型的快慢指针方法，慢指针记录非0元素，快指针遍历数组，但是由于还需要将0置于最后，所以还需要一次遍历
2. 一次遍历的话，主要是遍历数组中的每个元素，如果其非0则将其置换到左边，等于0的置换到右边

#### 844. 比较含退格的字符串

##### 题目描述：

​	给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

​	**注意：**如果对空文本输入退格字符，文本继续为空。

##### 题解：

+ 重构字符串
  + 最容易想到的方法是将给定的字符串中的退格符和应当被删除的字符都去除，还原给定字符串的一般形式。然后直接比较两字符串是否相等即可。
  + 具体地，我们用栈处理遍历过程，每次我们遍历到一个字符：
    + 如果它是退格符，那么我们将栈顶弹出；
    + 如果它是普通字符，那么我们将其压入栈中


```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        def build(s: str) -> str:
            ret = list()
            for ch in s:
                if ch != "#":
                    ret.append(ch)
                elif ret:
                    ret.pop()
            return "".join(ret)
        
        return build(S) == build(T)
```

+ 双指针法
  + 一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉
  + 具体地，我们定义 *skip* 表示当前待删除的字符的数量。每次我们遍历到一个字符：
    + 若该字符为退格符，则我们需要多删除一个普通字符，我们让 *skip* 加 1；
    + 若该字符为普通字符：
      + 若 *skip* 为 0，则说明当前字符不需要删去；
      + 若 *skip* 不为 0，则说明当前字符需要删去，我们让 *skip* 减 1

```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        i, j = len(S) - 1, len(T) - 1
        skipS = skipT = 0

        while i >= 0 or j >= 0:
            while i >= 0:
                if S[i] == "#":
                    skipS += 1
                    i -= 1
                elif skipS > 0:
                    skipS -= 1
                    i -= 1
                else:
                    break
            while j >= 0:
                if T[j] == "#":
                    skipT += 1
                    j -= 1
                elif skipT > 0:
                    skipT -= 1
                    j -= 1
                else:
                    break
            if i >= 0 and j >= 0:
                if S[i] != T[j]:
                    return False
            elif i >= 0 or j >= 0:
                return False
            i -= 1
            j -= 1
        
        return True

```

##### 总结：

1. 第一种可能更加贴近平时的积累，但是由于堆栈不经常使用了，还是需要强化记忆这部分
2. 第二种的话，我觉得主要是关于逆序遍历这种想法的没有意识，并且想到用skip去保存还需要退的元素个数，但其实本质上还是堆栈的问题没有解决！！！！因为后面的字母一定是保留在栈的最顶部的，所以保留！！！
3. 所以，需要培养堆栈的代码和思维意识！

### 977. 有序数组的平方

#### 题目描述：

​	给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

#### 题解：

+ 我的答案（好菜哦）==其实就是归并排序的思想👏==

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        res = [] #保留最终结果的列表
        pivot = 0 #记录第一个大于等于0的数，中枢
        min_squre = nums[0] * nums[0]
        for i in range(len(nums)):
            if((nums[i] * nums[i]) <= min_squre):
                pivot = i
                min_squre = nums[i] * nums[i]
        i, j = pivot - 1, pivot #i向x轴负半轴遍历，j向x轴正半轴遍历
        while((i >= 0) and (j < len(nums))):
            if((nums[i] * nums[i]) <= (nums[j] * nums[j])):
                res.append(nums[i] * nums[i])
                i -= 1
            else:
                res.append(nums[j] * nums[j])
                j += 1
        while(j < len(nums)):
            res.append(nums[j] * nums[j])
            j += 1
        while(i >= 0):
            res.append(nums[i] * nums[i])
            i -= 1
        return res

```

+ 最优解(还是从逆序，反向思维去考虑)

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        ans = [0] * n
        
        i, j, pos = 0, n - 1, n - 1
        while i <= j:
            if nums[i] * nums[i] > nums[j] * nums[j]:
                ans[pos] = nums[i] * nums[i]
                i += 1
            else:
                ans[pos] = nums[j] * nums[j]
                j -= 1
            pos -= 1
        
        return ans

```

#### 总结：

1. 我的双指针解法，需要找到一个平方值最小的边界，然后往两侧去进行依次元素的平方比较。同时呢，又可以看成，左边是一个递减数列，右边是一个递增数列，然后对该两者进行一个递归排序
   1. ==这边容易错误的点==在于，一边达到边界之后，另一侧还需要继续访问！！！
   2. <font color = red>低级错误！！！</font> 一定要记得去更新！！！比如说这题的最小值，千万不能忘记了更新！！！
2. 官方最优双指针解法，不需要确认中间边界，直接从两端开始，利用双指针进行遍历！！！！

### 209. 长度最小的子数组

#### 题目描述：

​	给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

#### 题解：

+ 我的题解：暴力法，但是会导致最终的`target`很大时，超出时间限制

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        s_min = len(nums) #用来记录最小子数组的长度
        final_num = 0 #用来记录长度最小的子数组的和
        for i in range(len(nums)):
            total = nums[i] #用来记录子数组和
            s_real = 1 #用来记录实时滑动窗口大小
            j = i + 1
            while(j < len(nums) and total < target):
                total += nums[j]
                j += 1
                s_real += 1
            if(total >= target and s_real <= s_min):
                s_min = s_real
                final_num = target
        if(final_num >= target):
            return s_min
        else:
            return 0
```

+ 由于第一种暴力解法，需要两次遍历完整数组，也就是时间复杂度为$O(n^2)$，因此我们可以考虑在寻找最佳位置的时候使用二分法，来简化时间复杂度。==需要注意的是==二分法一定得是！！有序数组！！

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1
        sums = [0]
        for i in range(n):
            sums.append(sums[-1] + nums[i])
        
        for i in range(1, n + 1):
            target = s + sums[i - 1]
            bound = bisect.bisect_left(sums, target) #用于在 有序列表 中找到一个元素的插入位置，以保持列表的有序性。它返回的是第一个 大于等于目标值 的索引。
            if bound != len(sums):
                ans = min(ans, bound - (i - 1))
        
        return 0 if ans == n + 1 else ans
```

+ 滑动窗口法
  + 在方法一和方法二中，都是每次确定子数组的开始下标，然后得到长度最小的子数组，因此时间复杂度较高。为了降低时间复杂度，可以使用滑动窗口的方法。
  + 定义两个指针 start 和 end 分别表示子数组（滑动窗口窗口）的开始位置和结束位置，维护变量 sum 存储子数组中的元素和（即从 nums[start] 到 nums[end] 的元素和）。
  + 初始状态下，*start* 和 *end* 都指向下标 0，*sum* 的值为 0。
  + 每一轮迭代，将 nums[end] 加到 sum，如果 sum≥s，则更新子数组的最小长度（此时子数组的长度是 end−start+1），然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum<s，在此过程中同样更新子数组的最小长度。在每一轮迭代的最后，将 end 右移。


```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1
        start, end = 0, 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1
        
        return 0 if ans == n + 1 else ans

```

#### 总结：

1. 如下图所示出现的问题，由于前面的数据不满足题意，因此在出现有效子数组时，会导致``s_min`变量值变为1，以至于存储实际有效实时滑动窗口实效，导致最小窗口一直为1。

![image-20251008094059251](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251008094059251.png)

2. 二分法的使用还需加强，**`python`中的`bisect.bisect_left`的方法含义**
3. 滑动窗口法，主要是窗口可以自行根据与target值的大小关系进行放大和缩小

#### 相关题目：

####  904. 水果成蓝【中等】

##### 题目描述：

​	你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

​	你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

​	给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

##### 题解：

+ 我的解法：
  + 参考长度最小的子数组的解法，想到使用滑动窗口
  + 用`first` 、`second`来表示滑动窗口内的第一个、第二个出现的数字（==值得注意的是==第一个出现的字可能在滑动窗口的**最后**！！！）
  + `num_max`表示滑动窗口的最大值，更大值来不断更迭
  + `i`表示第一个数字出现的第一个位置，也就是滑动窗口的头部
  + `j`表示滑动窗口的尾部（<font color = red>注意：</font>尾部的数字可能是`first`也可能是`second`）
  + 算法逻辑：
    + 通过`j`逐步递增，不断遍历数组
    + 每次出现第三个数字时，记录为`loc`
    + 计算此时滑动数组的长度，如果大于`num_max`则替换其值
    + 同时记录滑动窗口最后出现的数为`first`并通过向前遍历，得到`first`第一次出现的地方记录为`i`
    + 再将`loc`赋值给`j`，回到第一步

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        if not fruits:
            return 0
        first, second = fruits[0], 0 #first记录滑动窗口中第一个篮子的水果，second记录第二个篮子的水果
        num_max = 0
        i, j =0, 1 #保存first出现的第一个位置, j保存second出现的最后一个位置
        loc = 0
        #找出第二个篮子装什么水果      
        while(j < len(fruits)):
            if (fruits[j] != first):
                second = fruits[j]
                j += 1 #保存第二个篮子数字第一次出现的位置
                break
            j += 1 #保存第二个篮子数字第一次出现的位置
        while(j < len(fruits)):
            if ((fruits[j] == first) or (fruits[j] == second)):
                j += 1
            else:
                if((j - i) > num_max):
                    num_max = j - i
                if fruits[j - 1] == first:
                    second = first
                loc = j
                j -= 1
                while(j >= 0):
                    if(fruits[j] == second):
                        j -= 1
                    else:
                        i = j + 1
                        first = second
                        second = fruits[loc]
                        j = loc
                        break
        if((j - i) > num_max):
            num_max = j - i
        return num_max
```

+ 官方解法
  + 我们可以使用滑动窗口解决本题，left 和 right 分别表示满足要求的窗口的左右边界，同时我们使用哈希表存储这个窗口内的数以及出现的次数。
  + 我们每次将 right 移动一个位置，并将 fruits[right] 加入哈希表。如果此时哈希表不满足要求（即哈希表中出现超过两个键值对），那么我们需要不断移动 left，并将 fruits[left] 从哈希表中移除，直到哈希表满足要求为止。
  + 需要注意的是，将 fruits[left] 从哈希表中移除后，如果 fruits[left] 在哈希表中的出现次数减少为 0，需要将对应的键值对从哈希表中移除。

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        cnt = Counter()

        left = ans = 0
        for right, x in enumerate(fruits):
            cnt[x] += 1
            while len(cnt) > 2:
                cnt[fruits[left]] -= 1
                if cnt[fruits[left]] == 0:
                    cnt.pop(fruits[left])
                left += 1
            ans = max(ans, right - left + 1)
        
        return ans

```

##### 总结：

+ 解题过程失误
  + 是保留最大or最小值，搞糊涂了，循环条件，`break`没有使用
  + 如果前一个滑动窗口的末尾数是first的时候，要记得灵活转换
+ 与哈希表的第一次代码邂逅

#### 76. 最小覆盖字串【困难】

##### 题目描述：

​	给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

##### 题解：

+ 我的解法

```python
解不出来啊啊啊啊，主要是哈希表并不是很精通🤔
```

+ 大佬解法

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need, missing = collections.Counter(t), len(t) #记录 t 中每个字符还“需要”的次数（例如 t="AAB" 则 need={'A':2,'B':1}）
        i = start = end = 0
        for j, c in enumerate(s, 1):
            missing -= need[c] > 0
            need[c] -= 1
            if not missing:
                while need[s[i]] < 0:
                    need[s[i]] += 1
                    i += 1
                if not end or j - i < end - start:
                    start, end = i, j
        return s[start:end]
```

![image-20251010090545849](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090545849.png)

![image-20251010090610781](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090610781.png)

##### 总结：

+ `enumerate(sequence, [start=0])`
  + sequence -- 一个序列、迭代器或其他支持迭代对象。
  + start -- 下标起始位置的值。

![image-20251010090216855](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251010090216855.png)

+ 涉及滑动窗口的问题，都会在一个遍历全局的大循环下进行，然后再依次滑动，寻找适合的最佳解！！
+ 可以用`baacbac`来举例子方便记忆，主要是`missing原来可以第一次为0之后一直为0`这一点，我第一次遇到有点难以理解，`missing`为0之后，就依靠哈希表`need`来调控收缩！！！

## 59. 螺旋矩阵II

### 题目描述：

​	给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

### 题解：

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        matrix = [[0 for _ in range(n)] for _ in range(n)]
        num_move = 2 * n - 1 #一共需要方向改变的移动次数 按照下、左、上、右的顺序执行
        k = 1 #记录第几次执行方向改变了
        count = 1 #记录下一个数应该被写做几
        flag = True #是否为第一次改变方向，因为只有第一次只有保持一次所需修改的数量
        i, j = 0, 0 #表示行和列，便于修改元素
        iftwo = 0 #只有当达到2的倍数时，n才会减1
        final = 0 #记录最后的行列，即需保存的变量
        while(k <= num_move):
            #处理第一次向右
            if(flag and k % 4 == 1):
                i = 0
                for m in range(n):
                    matrix[i][m] = count
                    count += 1
                flag = False
                j = n - 1 #保留下次处理的不变列标
                n -= 1 #总变化数➖1
                i += 1 #开始变化行标
                k += 1
            #处理非第一次向右
            elif(k % 4 == 1):
                for m in range(n):
                    matrix[i][j + m] = count
                    count += 1
                    final = j + m
                j = final
                i += 1
                iftwo += 1
                if(iftwo % 2 == 0):
                    n -= 1
                k += 1
            #处理向下
            elif(k % 4 == 2):
                for m in range(n):
                    matrix[i + m][j] = count
                    count += 1
                    final = i + m
                i = final
                j -= 1 
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
            #处理向左
            elif(k % 4 == 3):
                for m in range(n):
                    matrix[i][j - m] = count
                    count += 1
                    final = j - m
                j = final
                i -= 1
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
            #处理向上
            else:
                for m in range(n):
                    matrix[i - m][j] = count
                    count += 1
                    final = i - m
                i = final
                j += 1
                iftwo += 1
                k += 1
                if(iftwo % 2 == 0):
                    n -= 1
        return matrix
 
```

![image-20251013093149397](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251013093149397.png)

<font color=red>官方的思路更加清晰，我的变量设置得很乱！</font>

### 总结：

1. 花了蛮长时间去做的，但是我很适合去暴力求解这些有规律的题目🤔哈哈哈，做出来还是很有成就感的
2. 注意的是：模拟过程！！
3. 值得注意⚠️的是，我自己设置的变量一定要记得变化呀==！！！！==

### 相关题目：

#### 54. 螺旋矩阵

##### 题目描述：

​	给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

##### 题解：

+ 模拟方法
  + 可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。
  + 判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。
  + 如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        visited = [[False] * columns for _ in range(rows)]
        total = rows * columns
        order = [0] * total

        directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        row, column = 0, 0
        directionIndex = 0
        for i in range(total):
            order[i] = matrix[row][column]
            visited[row][column] = True
            nextRow, nextColumn = row + directions[directionIndex][0], column + directions[directionIndex][1]
            if not (0 <= nextRow < rows and 0 <= nextColumn < columns and not visited[nextRow][nextColumn]):
                directionIndex = (directionIndex + 1) % 4
            row += directions[directionIndex][0]
            column += directions[directionIndex][1]
        return order
```

+ 按层模拟
  + 可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。
  + 定义矩阵的第 k 层是到最近边界距离为 k 的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2 层，剩下的元素都是第 3 层。
  + 对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于$(top,left)$，右下角位于 $(bottom,right)$，按照如下顺序遍历当前层的元素。

`````python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            # 这里必须严格控制小于，因为如果不是小于的话，则不存在
            if left < right and top < bottom:
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
`````

##### 总结：

1. 按层模拟，这个方法我觉得挺有效的！！！是一种化繁为简，逐层去考虑的思维方式！！！
2. 直接模拟的话，需要借助于辅助矩阵，判断是否被访问过，如果已经被访问过了，才会转向。同时，转向了，还需要记得修改移动路径和方式！！！



## 58. 区间和

### 题目描述：

![image-20251014135827118](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251014135827118.png)

### 题解：

```python
import sys
input = sys.stdin.read

def main():
    data = input().split()
    index = 0
    n = int(data[index])
    index += 1
    vec = []
    for i in range(n):
        vec.append(int(data[index + i]))
    index += n

    p = [0] * n
    presum = 0
    for i in range(n):
        presum += vec[i]
        p[i] = presum

    results = []
    while index < len(data):
        a = int(data[index])
        b = int(data[index + 1])
        index += 2

        if a == 0:
            sum_value = p[b]
        else:
            sum_value = p[b] - p[a - 1]

        results.append(sum_value)

    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```

### 总结：

+ ==前缀和！！！==（以应对暴力法导致的时间复杂度问题）
  + 重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数
+ <font color=red>需要特别注意⚠️的是：</font>
  + 下标区间和，一定要辨别清楚
  + 例如：求A数组下标[2, 5]区间的和 <> A[2] + A[3] + A[4] + A[5] <> P[5] - P[1]
    + 而不是P[5] - P[2]
    + P数组表示前n项和  
+ `data = input().split()`
  + `input()`函数用于从用户那里接收输入，返回的是字符串类型的数据
  + `split()` 函数用于将字符串分割成列表
    + 默认按照空格将字符串分割，并返回一个列表

## 44. 开发商购买土地

### 题目描述：

![image-20251016132435492](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251016132435492.png)

### 题解：

```python
def main():
    import sys
    input = sys.stdin.read
    data = input().split()

    idx = 0
    n = int(data[idx])
    idx += 1
    m = int(data[idx])
    idx += 1
    sum = 0
    vec = []
    for i in range(n):
        row = []
        for j in range(m):
            num = int(data[idx])
            idx += 1
            row.append(num)
            sum += num
        vec.append(row)

    # 统计横向
    horizontal = [0] * n
    for i in range(n):
        for j in range(m):
            horizontal[i] += vec[i][j]

    # 统计纵向
    vertical = [0] * m
    for j in range(m):
        for i in range(n):
            vertical[j] += vec[i][j]

    result = float('inf')
    horizontalCut = 0
    for i in range(n):
        horizontalCut += horizontal[i]
        # 这边是进行了一个简单的变换道理 要求min(b-a)且已知a+b=sum 则可等价得到下面的式子！！！
        result = min(result, abs(sum - 2 * horizontalCut))

    verticalCut = 0
    for j in range(m):
        verticalCut += vertical[j]
        result = min(result, abs(sum - 2 * verticalCut))

    print(result)

if __name__ == "__main__":
    main()
```

### 总结：

1. 前缀和：采用空间换时间的方法！！！！



# 链表

## 203. 移除链表元素

### 题目描述：

​	给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val`的节点，并返回 **新的头节点** 。

### 题解：

+ 我的思路：
  + 前置指针，方便删除元素
  + 工作指针，方便遍历链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        pre = head #前置指针，方便删除元素
        if(head == None):
            return head
        work = head.next #工作指针，方便遍历链表
        while(work):
            temp = work
            work = work.next
            if(temp.val == val):
                pre.next = work
            else:
                pre = temp
        work = head.next
        if(head.val == val):
            head = work
        return head
        
```

+ 递归解法：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if head is None:
            return head
        head.next = self.removeElements(head.next, val)
        return head.next if head.val == val else head
```

### 总结：

1. `python`链表，不能用下标进行访问而是得用`.`

2. 由于题设并没有头结点，而是直接指向<font color=red>第一个元素</font>，所以一定要想好临界条件

3. `python`使用问题，注意⚠️全局变量的问题！！！

   ![image-20251018113614920](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251018113614920.png)

   4. 链表问题一般都可用递归进行解决！！！一定要着重把握🫴❕
   5. 学会创建虚拟的头结点

   > ```python
   > # 创建虚拟头部节点以简化删除过程
   >      dummy_head = ListNode(next = head)
   > ```

## 707. 设计链表

   ### 题目描述：

   ​	你可以选择使用单链表或者双链表，设计并实现自己的链表。

   ​	单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

   ​	如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

   实现 `MyLinkedList` 类：

   - `MyLinkedList()` 初始化 `MyLinkedList` 对象。
   - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1`。
   - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
   - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
   - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
   - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

   ### 题解：

   + 单链表法：

   ```python
# 版本一）单链表法
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
        
class MyLinkedList:
    def __init__(self):
        self.dummy_head = ListNode() #设置虚拟的头结点
        self.size = 0 #不能忘记！！

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        
        current = self.dummy_head.next
        for i in range(index):
            current = current.next
            
        return current.val

    def addAtHead(self, val: int) -> None:
        self.dummy_head.next = ListNode(val, self.dummy_head.next)
        self.size += 1

    def addAtTail(self, val: int) -> None:
        current = self.dummy_head
        while current.next:
            current = current.next
        current.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        
        current = self.dummy_head
        for i in range(index):
            current = current.next
        current.next = ListNode(val, current.next)
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        current = self.dummy_head
        for i in range(index):
            current = current.next
        current.next = current.next.next
        self.size -= 1
   ```

   + 双链表法

   ```python
版本二）双链表法
class ListNode:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class MyLinkedList:
    def __init__(self):
      	# 注意双链表不需要设置头结点，直接使用即可	
        self.head = None
        self.tail = None
        self.size = 0 #不能忘记

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        
        #观察靠近头部还是尾部，方便进行遍历
        if index < self.size // 2:
            current = self.head
            for i in range(index):
                current = current.next
        else:
            current = self.tail
            for i in range(self.size - index - 1):
                current = current.prev
                
        return current.val

    def addAtHead(self, val: int) -> None:
        new_node = ListNode(val, None, self.head)
        if self.head:
            self.head.prev = new_node
        else:
            self.tail = new_node
        self.head = new_node
        self.size += 1

    def addAtTail(self, val: int) -> None:
        new_node = ListNode(val, self.tail, None)
        if self.tail:
            self.tail.next = new_node
        else:
            self.head = new_node
        self.tail = new_node
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        
        if index == 0:
            self.addAtHead(val)
        elif index == self.size:
            self.addAtTail(val)
        else:
            if index < self.size // 2:
                current = self.head
                for i in range(index - 1):
                    current = current.next
            else:
                current = self.tail
                for i in range(self.size - index):
                    current = current.prev
            new_node = ListNode(val, current, current.next)
            current.next.prev = new_node
            current.next = new_node
            self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        
        if index == 0:
            self.head = self.head.next
            if self.head:
                self.head.prev = None
            else:
                self.tail = None
        elif index == self.size - 1:
            self.tail = self.tail.prev
            if self.tail:
                self.tail.next = None
            else:
                self.head = None
        else:
            if index < self.size // 2:
                current = self.head
                for i in range(index):
                    current = current.next
            else:
                current = self.tail
                for i in range(self.size - index - 1):
                    current = current.prev
            current.prev.next = current.next
            current.next.prev = current.prev
        self.size -= 1总结：
   ```

### 总结：

+ 💡单链表存在头结点的必要性！！！
+ 🥚双链表可能不太需要头结点，也可以运行得很👌！



## 206. 反转链表

### 题目描述：

​	给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

### 题解：

+ 我的解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# 反转链表，其实就是头插法
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        dummyhead = ListNode() #设置虚拟头结点
        while(head):
            temp = head.next
            head.next = dummyhead.next
            dummyhead.next = head
            head = temp
        return dummyhead.next

```

+ 双指针法：
  + 定义一个`cur`指针，指向头结点，再定义一个`pre`指针，初始化为`null`
  + 使用`tmp`保存`cur.next`，因为下面需要进行改变`cur.next`都指向

```python
版本一）双指针法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        cur = head   
        pre = None
        while cur:
            temp = cur.next # 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur.next = pre #反转
            #更新pre、cur指针
            pre = cur
            cur = temp
        return pre
```

+ 递归法

```python
版本二）递归法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        return self.reverse(head, None)
    def reverse(self, cur: ListNode, pre: ListNode) -> ListNode:
        if cur == None:
            return pre
        temp = cur.next
        cur.next = pre
        return self.reverse(temp, cur)
```

### 总结：

+ 失误点：一定要注意⚠️插入节点的时候，前后都不可以==断开==

## 24. 两两交换列链表中的节点

### 题目描述：

​	给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

### 题解：

+ 我的解法
  + 先把奇偶链表单独拉出来
  + 再合并

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getlink(self, head:Optional[ListNode]) -> tuple:
        if(head == None): return None, None
        i = 3#用来记录是奇数还是偶数
        head_odd = None
        head_single = None
        tail_odd = None
        tail_single = None
        cur = None
        if(head.next):
            cur = head.next.next
        if(head.next):
            head_odd = head.next #定义偶数头结点
            tail_odd = head.next #定义偶数尾结点
            tail_odd.next = None
        head_single = head #定义奇数头结点
        tail_single = head #定义奇数尾结点
        tail_single.next = None
        while(cur):
            temp = cur.next
            if(i % 2 == 0):
                tail_odd.next = cur
                tail_odd = cur
            else: 
                tail_single.next = cur
                tail_single = cur
            i += 1
            cur = temp
        if(tail_odd):
            tail_odd.next = None
        if(tail_single):
            tail_single.next = None
        
        return head_odd, head_single
            

    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        head_odd, head_single = self.getlink(head)
        dummyhead = ListNode(0, None)
        tail = dummyhead
        i = 2

        while(head_odd or head_single):
            if(i % 2 == 0 and head_odd):
                tail.next = head_odd
                tail = head_odd
                if(head_odd):
                    head_odd = head_odd.next
            else:
                tail.next = head_single
                tail = head_single
                if(head_single):
                    head_single = head_single.next
            i += 1
        tail.next = None
        return dummyhead.next
```

+ 直接交换

`````python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None or head.next is None:
            return head

        # 待翻转的两个node分别是pre和cur
        pre = head
        cur = head.next
        next = head.next.next
        
        cur.next = pre  # 交换
        pre.next = self.swapPairs(next) # 将以next为head的后续链表两两交换
         
        return cur
`````

+ 递归

```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy_head = ListNode(next=head)
        current = dummy_head
        
        # 必须有cur的下一个和下下个才能交换，否则说明已经交换结束了
        while current.next and current.next.next:
            temp = current.next # 防止节点修改
            temp1 = current.next.next.next
            
            current.next = current.next.next
            current.next.next = temp
            temp.next = temp1
            current = current.next.next
        return dummy_head.next
```

### 总结：

+ 问题：👉 听起来合理，但**关键问题出在：你返回的“奇链”和“偶链”其实是共享原始节点的，而你在第一次调用 `getlink` 时已经修改了 `.next` 指针，导致第二次调用时原始链表已经被破坏！**
+ 使用tuple返回多个元素值
+ 通过保存前后结点，那么你可以直接进行调换

## 19. 删除链表的倒数第N个结点

### 题目描述：

​	给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

### 题解：

+ 我的解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        if(head == None): return None
        cur = head
        num = 0 #记录一共有多少个结点
        # 先遍历得到一共有多少个结点
        while(cur):
            num += 1
            cur = cur.next
        remove_loc = num - n # 记录是第几个数
        if(remove_loc < 0): return None
        record = 0 #当前遍历到第几个数，我们需要遍历到被删除的数之前
        pre = ListNode(0, head)
        cur = pre
        while(record < remove_loc):
            cur = cur.next
            record += 1
        cur.next = cur.next.next
        return pre.next
```

+ 双指针法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # 创建一个虚拟节点，并将其下一个指针设置为链表的头部
        dummy_head = ListNode(0, head)
        
        # 创建两个指针，慢指针和快指针，并将它们初始化为虚拟节点
        slow = fast = dummy_head
        
        # 快指针比慢指针快 n+1 步
        for i in range(n+1):
            fast = fast.next
        
        # 移动两个指针，直到快速指针到达链表的末尾
        while fast:
            slow = slow.next
            fast = fast.next
        
        # 通过更新第 (n-1) 个节点的 next 指针删除第 n 个节点
        slow.next = slow.next.next
        
        return dummy_head.next
```

### 总结：

+ 我觉得涉及到单链表，最好还是设置一个头结点
  + 方便遍历
  + 方便输出整个链表
+ 快慢指针的思想也应该好好把握！！！

## 面试题02.07. 链表相交

### 题目描述：

​	给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

![image-20251028224115042](https://cxycxycxydaydayup.oss-cn-shanghai.aliyuncs.com/picture/image-20251028224115042.png)

### 题解：

+ 我的解法

`````python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        numa = 0 #记录heada的长度
        numb = 0 #记录headb的长度
        cura = headA
        curb = headB
        dis = 0 # 记录长度之差
        while(cura):
            cura = cura.next
            numa += 1
        while(curb):
            curb = curb.next
            numb += 1
        if(numb >= numa): 
            longlist = headB
            shortlist = headA
            dis = numb - numa
        else:
            longlist = headA
            shortlist = headB
            dis = numa - numb
        index = 0
        while(index < dis and longlist):
            longlist = longlist.next
            index += 1
        while(longlist and shortlist):
            if(longlist == shortlist):
                return longlist
            longlist = longlist.next
            shortlist = shortlist.next
        return None
`````

`````python
版本一）求长度，同时出发

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lenA, lenB = 0, 0
        cur = headA
        while cur:         # 求链表A的长度
            cur = cur.next 
            lenA += 1
        cur = headB 
        while cur:         # 求链表B的长度
            cur = cur.next 
            lenB += 1
        curA, curB = headA, headB
        if lenA > lenB:     # 让curB为最长链表的头，lenB为其长度
            curA, curB = curB, curA
            lenA, lenB = lenB, lenA 
        for _ in range(lenB - lenA):  # 让curA和curB在同一起点上（末尾位置对齐）
            curB = curB.next 
        while curA:         #  遍历curA 和 curB，遇到相同则直接返回
            if curA == curB:
                return curA
            else:
                curA = curA.next 
                curB = curB.next
        return None 
        
版本二）求长度，同时出发 （代码复用）
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lenA = self.getLength(headA)
        lenB = self.getLength(headB)
        
        # 通过移动较长的链表，使两链表长度相等
        if lenA > lenB:
            headA = self.moveForward(headA, lenA - lenB)
        else:
            headB = self.moveForward(headB, lenB - lenA)
        
        # 将两个头向前移动，直到它们相交
        while headA and headB:
            if headA == headB:
                return headA
            headA = headA.next
            headB = headB.next
        
        return None
    
    def getLength(self, head: ListNode) -> int:
        length = 0
        while head:
            length += 1
            head = head.next
        return length
    
    def moveForward(self, head: ListNode, steps: int) -> ListNode:
        while steps > 0:
            head = head.next
            steps -= 1
        return head

版本三）求长度，同时出发 （代码复用 + 精简）
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        dis = self.getLength(headA) - self.getLength(headB)
        
        # 通过移动较长的链表，使两链表长度相等
        if dis > 0:
            headA = self.moveForward(headA, dis)
        else:
            headB = self.moveForward(headB, abs(dis))
        
        # 将两个头向前移动，直到它们相交
        while headA and headB:
            if headA == headB:
                return headA
            headA = headA.next
            headB = headB.next
        
        return None
    
    def getLength(self, head: ListNode) -> int:
        length = 0
        while head:
            length += 1
            head = head.next
        return length
    
    def moveForward(self, head: ListNode, steps: int) -> ListNode:
        while steps > 0:
            head = head.next
            steps -= 1
        return head

（版本四）等比例法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        # 处理边缘情况
        if not headA or not headB:
            return None
        
        # 在每个链表的头部初始化两个指针
        pointerA = headA
        pointerB = headB
        
        # 遍历两个链表直到指针相交
        while pointerA != pointerB:
            # 将指针向前移动一个节点
            pointerA = pointerA.next if pointerA else headB
            pointerB = pointerB.next if pointerB else headA
        
        # 如果相交，指针将位于交点节点，如果没有交点，值为None
        return pointerA
`````

### 总结：

+ 老毛病：前面设置的参数，进入循环，要增加啊，不然怎么退出循环呢？？！！！
+ 还有你计算来一个后面要用的变量，你就用变量保存！！不然容易后面忘记更新使用来。

## 142. 环形链表II

### 题目描述：

​	给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

​	如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

​	**不允许修改** 链表。

### 题解：

+ 快慢指针法

```python
（版本一）快慢指针法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
            # If there is a cycle, the slow and fast pointers will eventually meet
            if slow == fast:
                # Move one of the pointers back to the start of the list
                slow = head
                while slow != fast:
                    slow = slow.next
                    fast = fast.next
                return slow
        # If there is no cycle, return None
        return None
```

+ 集合法

```python
（版本二）集合法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None


class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        visited = set()
        
        while head:
            if head in visited:
                return head
            visited.add(head)
            head = head.next
        
        return None
```

### 总结

+ 集合法想到了，但是代码能力不会写😢
+ 快慢指针法：
  + 判断有环
    + 可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。
  + 如何找到入口
    + 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。





